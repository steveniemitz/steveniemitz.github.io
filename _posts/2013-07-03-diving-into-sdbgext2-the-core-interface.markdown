---
layout: post
title: Diving into SDbgExt2, the core interface
date: '2013-07-03 23:19:21'
---

<p>The SDbgCore static library is the foundation of SDbgExt2.&#160; It contains the definition of <strong>IXCLRDataProcess3</strong> (I think it’s the 3rd revision, I just made the name up), as well as the core classes and interfaces <strong>IClrProcess</strong> and <strong>ISDbgExt</strong>.&#160; It also contains many helper interfaces such as <strong>IClrObject(Array)</strong>, and lots of callback interfaces.&#160; We’ll go through these one by one.</p>
  <h2></h2>  <h2>IXCLRDataProcess3</h2>  <p>This is the interface that makes everything work.&#160; In the pervious version (.NET 4.0), almost all functions were executed via a single Request(…) method on the interface.&#160; In .NET 4.5, these requests were split into strongly typed functions.&#160; </p>
  <p>I started by reverse engineering the VTable via the embedded symbols in mscordacwks.dll.&#160; The interface is implemented by ClrDataAccess, and is the 3rd interface in the VTable (hence IXCLRDataProcess3).&#160; Next, I began reverse engineering the parameters.&#160; This is obviously more difficult, but you can get an idea of the parameters in two ways.&#160; </p>
  <p>First, since most functions are similar to their request counterparts in .NET 4, you can get an idea of the parameters via the request object.&#160; Second, by inspecting the call sites in SOS, we can get an idea of the parameters being passed in.&#160; It turns out that a large chunk of functions follow a few very similar signatures, so figuring out the parameter isn’t actually that tough.&#160; Also as a side note, the x86 calling convention (stdcall) here makes it a lot easier to reverse engineer than x64, so I did most of my reversing on the x86 version.</p>
  <p>For the output structures, again I leveraged .NET 4.0’s structures.&#160; Obviously there were some changes / additions / removals, but again by looking at the call site in SOS, it’s not too hard to figure out which fields do what.&#160; Some of these structures are obviously incomplete, but there’s enough there to support the functionality I need.</p>
  <p>The result of this is IXCLRDataProcess3.idl, which MIDL compiles to a C++ interface and type library.</p>
  <h2>ClrProcess</h2>  <p>ClrProcess is the lowest level new interface in SDbgExt2.&#160; It contains various utility methods, field accessors, heap enumeration, sort-of-reflection, and thread inspection.&#160; I tried to keep this interface as low-level as possible, which providing reusable methods for what would be used by the higher level methods.</p>
  <p>For example, accessing a static field (see <a href="https://github.com/steveniemitz/SDbgExt2/blob/master/SDbgCore/src/ClrProcess_Fields.cpp#L24" target="_blank">ClrProcess::GetStaticFieldValue</a>) via IXCLRDataProcess3 is a fairly complicated process.&#160; This is the simplified algorithm:</p>
  <ol>   <li>You need to find the actually field address (the FieldDesc)      <ol>       <li>This can be done by scanning the method table recursively, and using IMetaDataImport to resolve a token to a name. </li>     </ol>   </li>    <li>Given a FieldDesc and app domain, figure out the module that contains it. </li>    <li>Figure out if the module has data in the domain-neutral store or not.      <ol>       <li>If so, use that to get the domain local module data </li>     </ol>   </li>    <li>Otherwise, use the app domain’s domain local module data. </li>    <li>Using the DLM data, use the GCStaticDataStart, or NonGCStaticDataStart (for non-reference types) to find the base offset </li>    <li>Add the field’s static offset to the base offset to get where in memory the field is </li>    <li>Read from the memory offset to get the field value. </li> </ol>  <p><strong>Next up: more details on implementing ClrProcess</strong></p>
